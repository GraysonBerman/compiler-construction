# BNFC installation

The [BNFC homepage](http://bnfc.digitalgrammars.com/) is the first place to go, but installation instructions in the [BNFC tutorial](http://bnfc.digitalgrammars.com/tutorial/bnfc-tutorial.html) are out of date, so we need to work a bit to find our way. I will add information here as we go along and learn more about the best way to get this done. Let me know about anything that may be usefull to add. 

## Working under Windows

Download the [binaries](https://github.com/BNFC/bnfc/releases).

I don't use Windows, so I am dependent on your feedback to put more information here ...

it may be the case that Windows does not know about `make` ... installing cygwin is a solution ...

## Working under Linux/MacOS

Installing BNFC under Linux/MacOS requires installing Haskell and Cabal and compiling the source code. 

Download and install Haskell.

Create a directory in which you want to clone the BNFC github directory and `cd` there in a terminal. Then perform the following commands.

    git clone https://github.com/BNFC/bnfc
    cd bnfc
    make
    
The last lines of the compilation give me

           Configuring BNFC-2.8.3...
           cabal: Encountered missing dependencies:
           doctest >=0.8, hspec -any, temporary -any

           make: *** [internal-tests] Error 1
        
As far as I understand these can be ignored as long as the executable `bnfc` was generated.

Now we need to make sure that the operating system finds bnfc when typing `bnfc` in the terminal. For example, if you enter `bnfc --version` you may get a `command not found` message. Use your file browser to find where the exectuable bnfc is. I found it as `bnfc/source/dist/build/bnfc`. Now you need to make sure that it will be "in the path". Entering `echo $PATH` in your terminal shows the value of the variable `PATH`, that is, all the directories at which the operating system automatically looks for executables (binaries). Either copy `bnfc` into a directory in your path, or change `PATH` to contain `bnfc/source/dist/build/`. More on how to change `PATH` can be found [here](https://www.computerhope.com/issues/ch001647.htm) or in many other places. <sup>[[1]](#hidden)</sup> Let me know if you have a favourite reference.
 
Now, on entering `bnfc --version` you should see `2.8.3`. (Or some larger number if you are doing this in the future.)

We can now continue with creating a parser for our calculator.

    cd examples
    bnfc -m -haskell Calc.cf
    make
    echo "23 + 4 * 70" | ./TestCalc 
    
This should show you that the parser generated by bnfc can parse the expression "23 + 4 * 70". Also check out the official BNFC tutorial for more information.
 
The next step is to create an interpreter that is able to perform computations such as `23 + 4 * 70`. We will learn later more about how this works, now it is just important to get things running.
 
    cp ../document/tutorial/calc/haskell/Interpreter.hs .
  
modify TestCalc.hs as discribed in the [slides](http://www.grammaticalframework.org/ipl-book/slides/2-slides-ipl-book.pdf) on page 33 and save the file as Calculator.hs <sup>[[2]](#footnote)</sup>
  
    ghc --make Calculator.hs
    echo "1 + 2 * 3" | ./Calculator
    
you have successfully compiled and run your first program

---

<a name="hidden">[1]</a>: In a MacOS file dialogue you can see hidden files such as `.bash_profile` by simultaneously holding down the keys "command" and "shift" and "." Alternative you use the terminal as, for example, in `open -a TextEdit .bash_profile` or `open -a Sublime\ Text\ 2 .bash_profile` to open the `.bash_profile` (thanks to Dylan Davis).

<a name="footnote">[2]</a>: What is going on here? Remember that `TestCalc` printed the abstract syntax tree. The slides show you how to replace the code of the `main` function that printed the abstract syntax tree by code that interpretes the abstract syntax tree. Essentially, interpreting is very similar to printing. In both cases one walks recursively through the abstract syntax tree. For interpreting as opposed to printing, instead of calling the print function, just call the addition function of the host langauge on encountering a node labelled `EAdd` in the tree (imilarly for `EMul`).
